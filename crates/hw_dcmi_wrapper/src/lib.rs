//! # HW_DCMI
//!
//! Huawei Ascend computing device **third-party** DCMI c library **safe** FFI binding
//!
//! - `hw_dcmi_wrapper` provides safe FFI bindings (encapsulated from the FFI bindings provided by hw_dcmi_wrapper_sys)
//! - `hw_dcmi_wrapper_sys` provides unsafe FFI bindings (directly generated by bindgen)
//!
//! ## Usage
//! ### Prerequisites
//! project has been tested on Ubuntu 22.04, with Atlas 6.0.0 DCMI API, you need to install the following dependencies:
//!
//! - DCMI shared library
//! - Ascend driver
//!
//! by default, library will try to find `dcmi_interface_api.h` and link `libdcmi.so` in `/usr/local/dcmi`,
//! you can provide `HW_DCMI_PATH` env variable to specify the path of the dcmi shared library.
//!
//! If you want to regenerate bindings, you can set `HW_DCMI_BINDING_BUILD` to `true` to regenerate bindings,
//! the generated bindings will be saved in:
//! - Static link: `hw_dcmi_wrapper_sys/src/bindings.rs`
//! - Dynamic link: `hw_dcmi_wrapper_sys/src/bindings_dyn.rs`
//!
//! ### Example
//! - Before using any DCMI API, you need to initialize the library first. You can Initialize the library with `Dcmi::init`
//! - Most API interfaces are encapsulated to conform to ergonomics, such as `Card: Query_cards` returned a `Vec<Card>`.
//! - If you are confident that the parameters are correct, you can use `Card::new_uncheck`to create a `Card` instance.
//!
//! ## Feature flag
//! - `serde`: enable serde serialization and deserialization for all types in hw_dcmi_wrapper
//! - `load_dynamic`: enable dynamic loading of the dcmi shared library
#![warn(missing_docs)]

use crate::enums::HealthState;
use crate::error::{dcmi_try, DCMIResult};
use std::cell::Cell;

use hw_dcmi_wrapper_sys::bindings as ffi;
use static_assertions::{assert_impl_all, assert_not_impl_all};

#[macro_use]
mod macros;
pub mod device;
pub mod enums;
pub mod error;
pub mod structs;
#[cfg(test)]
mod test;

/// DCMI
///
/// As mentioned in the reference manual, the DCMI must be initialized before use.
///
/// Regardless of whether you use the 'load.dynamic' feature or not, the Init structure will ensure the correct initialization of DCMI
/// All DCMI library calls require&DCMI to ensure that requests are legal
/// When you need multiple requests, consider using static save to avoid duplicate initialization
///
/// # Concurrency
/// According to the Huawei document, DCMI API could not be used in multi-thread. so it not implement `Sync`.
///
/// you can use `Arc<Mutex<DCMI>>` to wrap the DCMI instance if you need to share it across threads.
///
/// # Example
/// ```rust no_run
/// # use hw_dcmi_wrapper::DCMI;
/// use hw_dcmi_wrapper::device::card::Card;
/// let dcmi = DCMI::init().unwrap();
///
/// let dcmi_version = dcmi.get_dcmi_version().unwrap();
/// println!("DCMI version: {}", dcmi_version);
///
/// let cards = Card::query_cards(&dcmi).unwrap();
/// println!("Card list: {:?}", cards);
/// ```
#[cfg(not(feature = "load_dynamic"))]
#[derive(Debug)]
pub struct DCMI {
    _no_sync_marker: std::marker::PhantomData<Cell<u32>>,
}

/// DCMI
///
/// As mentioned in the reference manual, the DCMI must be initialized before use.
///
/// Regardless of whether you use the 'load.dynamic' feature or not, the Init structure will ensure the correct initialization of DCMI
/// All DCMI library calls require&DCMI to ensure that requests are legal
/// When you need multiple requests, consider using static save to avoid duplicate initialization
///
/// # Concurrency
/// According to the Huawei document, DCMI API could not be used in multi-thread. so it not implement `Sync`.
///
/// you can use `Arc<Mutex<DCMI>>` to wrap the DCMI instance if you need to share it across threads.
///
/// # Example
/// ```rust no_run
/// # use hw_dcmi_wrapper::DCMI;
/// use hw_dcmi_wrapper::device::card::Card;
/// let dcmi = DCMI::init().unwrap();
///
/// let dcmi_version = dcmi.get_dcmi_version().unwrap();
/// println!("DCMI version: {}", dcmi_version);
///
/// let cards = Card::query_cards(&dcmi).unwrap();
/// println!("Card list: {:?}", cards);
/// ```
#[cfg(feature = "load_dynamic")]
pub struct DCMI {
    pub(crate) lib: ffi::dcmi,
    _no_sync_marker: std::marker::PhantomData<Cell<u32>>,
}

#[cfg(feature = "load_dynamic")]
impl std::fmt::Debug for DCMI {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DCMI")
    }
}

assert_impl_all!(DCMI: Send);
assert_not_impl_all!(DCMI: Sync);

impl DCMI {
    /// Initialize the DCMI
    ///
    /// As documented in the reference manual, the DCMI must be initialized before use.
    pub fn init() -> DCMIResult<Self> {
        #[cfg(feature = "load_dynamic")]
        let lib = {
            let hw_dcmi_path =
                std::env::var("HW_DCMI_PATH").unwrap_or_else(|_| "/usr/local/dcmi".to_string());
            let lib_path = format!("{}/libdcmi.so", hw_dcmi_path);
            unsafe { ffi::dcmi::new(lib_path) }.expect("Failed to load DCMI library dynamically")
        };

        let res = unsafe {
            #[cfg(feature = "load_dynamic")]
            {
                lib.dcmi_init()
            }

            #[cfg(not(feature = "load_dynamic"))]
            {
                ffi::dcmi_init()
            }
        };

        dcmi_try(res)?;

        let dcmi = DCMI {
            #[cfg(feature = "load_dynamic")]
            lib,
            _no_sync_marker: std::marker::PhantomData,
        };
        Ok(dcmi)
    }

    /// Get the DCMI version
    ///
    /// # Returns
    /// DCMI version
    pub fn get_dcmi_version(&self) -> DCMIResult<String> {
        let mut dcmi_ver = [0u8; 16]; // 分配一个 16 字节的数组，用于存储 C 字符串
        let len = dcmi_ver.len() as u32;

        // 调用 C 函数
        call_dcmi_function!(
            dcmi_get_dcmi_version,
            self.lib,
            dcmi_ver.as_mut_ptr() as *mut ::std::os::raw::c_char,
            len
        );

        Ok(std::str::from_utf8(&dcmi_ver)?.into())
    }

    /// Get the driver version
    ///
    /// # Returns
    /// driver version
    pub fn get_driver_version(&self) -> DCMIResult<String> {
        let mut driver_ver = [0u8; 64];
        let len = driver_ver.len() as u32;

        call_dcmi_function!(
            dcmi_get_driver_version,
            self.lib,
            driver_ver.as_mut_ptr() as *mut ::std::os::raw::c_char,
            len
        );

        Ok(std::str::from_utf8(&driver_ver)?.into())
    }

    /// Query target device driver version
    ///
    /// # Parameters
    /// - card_id: Specify the NPU management unit ID, and obtain the currently supported IDs through the `get_card_list`
    /// - device_id: Specify the device ID, and obtain the supported IDs through the `get_device_id_in_card`
    ///
    /// # Returns
    /// driver version
    #[deprecated = "As mentioned in Huawei document, this function will delete later, Use `get_driver_version` instead"]
    pub fn get_version(&self, card_id: u32, chip_id: u32) -> DCMIResult<String> {
        let mut driver_ver = [0u8; 64];
        let len = driver_ver.len() as u32;
        let mut ver_len = 0i32;

        call_dcmi_function!(
            dcmi_get_version,
            self.lib,
            card_id as std::os::raw::c_int,
            chip_id as std::os::raw::c_int,
            driver_ver.as_mut_ptr() as *mut ::std::os::raw::c_char,
            len,
            &mut ver_len
        );

        Ok(std::str::from_utf8(
            &driver_ver
                .into_iter()
                .take(ver_len as usize)
                .collect::<Vec<_>>(),
        )?
        .into())
    }

    /// Query the driver health
    ///
    /// # Returns
    /// driver health
    pub fn get_driver_health(&self) -> DCMIResult<HealthState> {
        let mut health = 0u32;
        call_dcmi_function!(dcmi_get_driver_health, self.lib, &mut health);

        Ok(health.into())
    }

    /// Query the driver error code
    ///
    /// # Returns
    /// driver error code list
    pub fn get_driver_error_code(&self) -> DCMIResult<Vec<u32>> {
        let mut error_code_list = [0u32, 128];
        let mut error_count = 0i32;

        call_dcmi_function!(
            dcmi_get_driver_errorcode,
            self.lib,
            &mut error_count,
            error_code_list.as_mut_ptr(),
            128
        );

        Ok(error_code_list
            .into_iter()
            .take(error_count as usize)
            .collect())
    }

    /// Set the container service enable
    ///
    /// Initialize all devices in the current container for subsequent conversion between logical and physical IDs
    pub fn set_container_service_enable(&self) -> DCMIResult<()> {
        call_dcmi_function!(dcmi_set_container_service_enable, self.lib);
        Ok(())
    }
}
